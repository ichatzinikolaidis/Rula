# Maximum distance (in meters) that will be considered when taking the obstacle data and putting it to the costmap.
obstacle_range: 2.5
# Maximum distance (in meters) that will be considered when taking the free space around the robot and putting it to the costmap.
raytrace_range: 3.0

# Slightly greater than the robot’s height.
max_obstacle_height: 0.45
# Near the ground height.
min_obstacle_height: 0.05

# Even if you don’t have a circular robot, it's important to set the inflation_radius to the “maximum radius” of your robot, so the costmap creates a inflation around obstacles and the robot doesn’t collide, no matter what is it direction when getting close to obstacles.
inflation_radius: 0.43
# When you want a most precise representation of your robot, you have to comment the robot_radius parameter and create a custom footprint, considering [0, 0] as the center of your robot.
footprint: [[-0.3,-0.3],[-0.3,0.3], [0.3, 0.3], [0.3,-0.3]]
# Summed at each of the footprint points, both at the x and y coordinates.
footprint_padding: 0

# Sets the maximum latency accepted so the system knows that no link in the transform tree is missing. This parameter must be set in an interval that allows certain tolerable delays in the transform publication and detects missing transforms, so the Navigation Stack stops in case of flaws in the system.
transform_tolerance: 1.0
# Enforce we are using a costmap.
map_type: costmap
# Sets the scaling factor that applies over the inflation. This parameter can be adjusted so the robot has a more aggressive or conservative behavior near obstacles.
cost_scaling_factor: 10.0

#  Responsible for choosing the source of the sensor data.
observation_sources: laser_scan_sensor
laser_scan_sensor: {sensor_frame: laser_link, data_type: LaserScan, topic: /scan, marking: true, clearing: true}